Navigation Source File Documentation

Routines:

	- Class Initialization (init_nav())
		This routine will initialize private class variables (typically setting to zero) to guarantee initial values.
		It will do some basic error checking on the input array. It will store the array for use by the class.

		- Hides class variables that need to be set/reset and any other class startup procedures
		- Input: an array with route waypoints
		- Output: an error code if input is invalid
		- Precond: the input is an array of waypts
		- Postcond: the class is ready to be used, variables are all initially defined

		Test the routine by giving different inputs and viewing variable states upon return. Give arrays of different
		lengths, empty arrays, and arrays with junk values.

	- Array Validity Check (array_valid())
		This routine will check that the input array into 'init_nav()' is valid, meaning that it has greater than two
		values, and is not NULL. It will return a value depending on whether the input is valid or not.

		- Hides the error-checking procedures
		- Input: an array with route waypoints
		- Output: an success/failure code depending on the input validity
		- Precond: the input is an array of waypts
		- Postcond: the array is determined to be valid or not

		Test the routine with different input and viewing the returned code. Give arrays of different lengths, empty
		arrays, and arrays with junk values. Check border cases

	- Route Navigation (navigate_route())
		This routine is the main routine of the class and runs the user route navigation between waypoints. It is 
		called roughly every second to update the user about the next waypoint. It retrieves the latest GPS data, 
		determines the distance and bearing to the next	waypoint, updates information on the display, and vibrates the
		motors if necessary. 

		- Hides the logic and function calls behind route navigation
		- Input: none
		- Output: status of route (in progress, complete)
		- Precond: class variables initialized, valid GPS fix
		- Postcond: run complete and stats saved, or user quit

		Test the routine by running through different kinds of routes.

	- Distance Update (update_distance())
		This routine updates the total distance completed and distance remaining to the next waypoint based on the 
		distance traveled since the last routine call. It also updates the previous location of the user with the 
		current location.

		- Hides the validity check for the new location data
		- Input: none
		- Output: none
		- Precond: the current location has been updated and all variables used are valid
		- Postcond: distance variables updated with new information if new information valid

		Test the routine by feeding valid and invalid previous and current locations.

	- Calculate Distance Between Waypoints (dist_between_waypts())
		This routine calculates the equirectangular approximation of the distance between two (latitude, longitude)
		waypoints in meters. This approximation should work for distances of at least 100 km.

		- Hides the equations and type conversions
		- Input: two waypoint structures
		- Output: an integer distance between the waypoints in meters
		- Precond: inputs are valid waypoints with valid latitudes/longitudes
		- Postcond: output is a valid approximation of the distance between the inputs

		Test routine using waypoint at different magnitudes of distances and comparing to a known answer.

	- Determine If Near Waypoint (near_waypoint())
		This routine indicates whether or not the user is within a certain distance of the next waypoint, but not at
		the next waypoint.

		- Hides the logic statements
		- Input: the distance to the next waypoint
		- Output: a boolean that indicates if near the next waypoint
		- Precond: the input is a valid positive integer
		- Postcond: the returned value is a boolean

		Test the routine using different distances including invalid and border cases. 

	- Determine If At Waypoint (at_waypoint())
		This routine indicates whether or not the user is at the next waypoint. This means that the user is within a
		smaller distance than being near the waypoint.

		- Hides the logic statements
		- Input: the distance to the next waypoint
		- Output: a boolean that indicates if at the next waypoint
		- Precond: the input is a valid positive integer
		- Postcond: the returned value is a boolean

		Test the routine using different distances including invalid and border cases. 

	- Find Bearing To Waypoint (bearing_to_waypt())
		This routine finds the bearing from one latitude/longitude location to another in degrees. The first argument 
		is the starting location and the second is the destination.

		- Hides the mathematical calculations
		- Input: two waypoint structures
		- Output: a bearing in degrees in range 0-360
		- Precond: the inputs are valid waypoints with valid latitudes/longitudes
		- Postcond: the output is a valid bearing from first argument to the second argument

		Test the routine with different waypoints and output possibilities.

	- Find Direction To Turn To Waypoint (direction_to_turn())
		This routine finds the direction to turn for the user's heading to intersect the intended bearing.

		- Hides the logic statements
		- Input: user heading and waypoint bearing
		- Output: a direction enum indicating error or direction to turn
		- Precond: inputs are current
		- Postcond: given output will take user to waypoint

		Test the routine with different headings and bearings.

	- Vibrate Motors To Indicate Turn Direction (vibrate_motors())
		This routine vibrates the motors for user feedback based on the input arguments. It uses functions found in motor.h.

		- Hides the control logic
		- Input: a direction enum indicating error or direction to turn
		- Output: none
		- Precond: input is valid direction enum
		- Postcond: motor(s) vibrate or stop vibrating

		Test the routine using all valid and a couple invalid inputs.

	- Tell User Direction Of Next Waypoint (indicate_turn_direction())
		This routine finds the user's heading and the next waypoint's bearing, determines which direction to turn to
		get on the bearing, and vibrates the motors to tell the user which direction to turn. Alleviates some of the
		nested if statements in the navigate_route() function.

		- Hides a few function calls and a logic statement
		- Input: none
		- Output: none
		- Precond: none
		- Postcond: motor(s) vibrate or stop vibrating

		Test the routine during use. Check that if statement works.

	- Alert User If Off Course (off_course_correction())
		This routine alerts the user to the direction of the current waypoint if the user wanders off the bearing to
		the current waypoint.

		- Hides a few function calls and a logic statement
		- Input: none
		- Output: none
		- Precond: user is neither near nor at the current waypoint
		- Postcond: motor vibrates or stops vibrating

		Test the routine during use.
		
	- Save Run Statistics (eeprom_save_stats())
		This routine saves certain run statistics, like total distance and time, to the EEPROM for non-volatile storage.

		- Hides function calls and unit conversions
		- Input: none
		- Output: none
		- Precond: EEPROM not being used
		- Postcond: new values saved into EEPROM

		Test the routine using different times and distances and viewing EEPROM values.