/* 
 * oled.c
 *
 * Created: 2014/01/27
 * Author: Joel Heck
 *
 * SSD1306 OLED display driver communication library
 * 
 * See Driver Guide for buffer byte mapping to display pixels
 */

#include <avr/io.h>
#include <avr/pgmspace.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <util/delay.h>
#include "ascii_font.c"
#include "i2c.h"
#include "oled.h"


// Buffer to hold color (black or white) of each pixel in display
//static uint8_t display_buffer[DISPLAY_BUFFER_SIZE] = {0x00};

// Buffer to hold color (black or white) of each pixel in display
static uint8_t display_buffer[DISPLAY_BUFFER_SIZE] = {
	/* Page 1 */
	0x3E, 0x51, 0x49, 0x45, 0x3E, 0x00, 0x3E, 0x51, 0x49, 0x45, 0x3E, 0x00, 0x00, 0x00, 0x14, 0x00,
	0x00, 0x00, 0x3E, 0x51, 0x49, 0x45, 0x3E, 0x00, 0x3E, 0x51, 0x49, 0x45, 0x3E, 0x08, 0x08, 0x08,
	0xFF, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0xFF, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0xFF, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0xFF, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0xFF, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0xFF, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	/* Page 2 */
	0xF8, 0xF8, 0x06, 0x06, 0x86, 0x86, 0x66, 0x66, 0xF8, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00,
	0x00, 0x00, 0x3E, 0x51, 0x49, 0x45, 0x3E, 0x00, 0x3E, 0x51, 0x49, 0x45, 0x3E, 0x08, 0x08, 0x08,
	0xFF, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0xFF, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0xFF, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0xFF, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0xFF, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0xFF, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	/* Page 3 */
	0x1F, 0x1F, 0x66, 0x66, 0x61, 0x61, 0x60, 0x60, 0x1F, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00,
	0x00, 0x00, 0x3E, 0x51, 0x49, 0x45, 0x3E, 0x00, 0x3E, 0x51, 0x49, 0x45, 0x3E, 0x08, 0x08, 0x08,
	0xFF, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0xFF, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0xFF, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0xFF, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0xFF, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0xFF, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	/* Page 4 */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00,
	0x00, 0x00, 0x3E, 0x51, 0x49, 0x45, 0x3E, 0x00, 0x3E, 0x51, 0x49, 0x45, 0x3E, 0x08, 0x08, 0x08,
	0xFF, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0xFF, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0xFF, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0xFF, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0xFF, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0xFF, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	/* Page 5 */
	0xC0, 0xC0, 0xC0, 0xC0, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C,
	0xC0, 0xC0, 0xC0, 0xC0, 0x00, 0x45, 0x3E, 0x00, 0x3E, 0x51, 0x49, 0x45, 0x3E, 0x08, 0x08, 0x08,
	0xFF, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0xFF, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0xFF, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0xFF, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0xFF, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	/* Page 6 */
	0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xC0, 0xC0, 0xC0, 0x3C, 0x3C, 0x3C, 0x3C,
	0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x45, 0x3E, 0x00, 0x3E, 0x51, 0x49, 0x45, 0x3E, 0x08, 0x08, 0x08,
	0xFF, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0xFF, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0xFF, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0xFF, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0xFF, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0xFF, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	/* Page 7 */
	0xFF, 0xFF, 0xFF, 0xFF, 0x3C, 0x3C, 0x3C, 0x3C, 0x03, 0x03, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x45, 0x3E, 0x00, 0x3E, 0x51, 0x49, 0x45, 0x3E, 0x08, 0x08, 0x08,
	0xFF, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0xFF, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0xFF, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0xFF, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0xFF, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0xFF, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	/* Page 8 */
	0x03, 0x03, 0x03, 0x03, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C,
	0x03, 0x03, 0x03, 0x03, 0x00, 0x45, 0x3E, 0x00, 0x3E, 0x51, 0x49, 0x45, 0x3E, 0x08, 0x08, 0x08,
	0xFF, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0xFF, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0xFF, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0xFF, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0xFF, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0xFF, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08
};

/* Returns the byte in the buffer containing the desired pixel */
static uint16_t get_buffer_index(coordinate x_coord, coordinate y_coord) {
	uint16_t index = x_coord;
	index += (y_coord / BYTE_LENGTH) * OLED_WIDTH;

	return index;
}

/* Calculates a modulo of two numbers more efficiently than the mod operator */
static uint8_t modulus(coordinate argument, uint8_t divisor) {
	uint8_t multiple = (uint8_t) argument / divisor;
	uint8_t remainder = (uint8_t) argument - (multiple * divisor);

	return remainder;
}

/* Send a command byte */
static void oled_send_command(uint8_t command) {
	i2c_start(OLED_I2C_ADDRESS);
	
	// Indicate that a command follows
	i2c_write(COMMAND_TYPE);

	// Send the command
	i2c_write(command);
	i2c_stop();
}

/* Set a pixel white or black */
void oled_set_pixel(coordinate x_coord, coordinate y_coord, color pixel_color) {
	// Don't set pixels outside display area
	if ( (OLED_WIDTH <= x_coord) || (OLED_HEIGHT <= y_coord) ) {
		return;
	}

	uint16_t buffer_index = get_buffer_index(x_coord, y_coord);

	// Set pixel color in display buffer
	if (pixel_color == WHITE) {
		display_buffer[buffer_index] |= (1 << (modulus(y_coord, BYTE_LENGTH)) );
	}
	else {
		display_buffer[buffer_index] &= ~(1 << (modulus(y_coord, BYTE_LENGTH)) );
	}
}

/* Write the buffer to the display */
void oled_send_display() {
	
	// Start cursor at top, left pixel before sending data
	oled_send_command(OLED_SET_PAGE_START);
	oled_send_command(OLED_LOW_COLUMN);
	oled_send_command(OLED_HIGH_COLUMN);
	
	i2c_start(OLED_I2C_ADDRESS);

	// Indicate that data follows
	i2c_write(DATA_TYPE);

	// Send each byte in the display buffer
	uint16_t buffer_index = 0;
	while (buffer_index < DISPLAY_BUFFER_SIZE) {
		i2c_write(display_buffer[buffer_index]);
		buffer_index++;	
	}

	i2c_stop();
}

/* Clear display buffer */
void oled_clear_display_buffer() {
	memset(display_buffer, 0, DISPLAY_BUFFER_SIZE);
}

/* Initialize display with a reset and startup commands in given order */
void oled_init() {
	// Reset the display
	RESET_PORT &= ~(1 << RESET_PIN);
	//PORTA &= ~(1 << 3);
	_delay_ms(10.0);
	RESET_PORT |= (1 << RESET_PIN);
	//PORTA |= (1 << 3);
	
	oled_send_command(OLED_DISPLAY_OFF);
	
	/* Set by default during reset
	oled_send_command(OLED_SET_DISPLAY_CLK_DIV);
	oled_send_command(OLED_DISPLAY_CLK_DIV);
	oled_send_command(OLED_SET_MULTIPLEX);
	oled_send_command(OLED_MULTIPLEX_RATIO);
	oled_send_command(OLED_SET_DISPLAY_OFFSET);
	oled_send_command(OLED_DISPLAY_OFFSET);
	oled_send_command(OLED_START_LINE);
	*/
	
	oled_send_command(OLED_SET_CHARGE_PUMP);
	oled_send_command(OLED_CHARGE_PUMP);	
	
	// Set the memory addressing mode to horizontal with full display
	oled_send_command(OLED_SET_MEMORY_MODE);
	oled_send_command(OLED_HORIZ_MODE);
	oled_send_command(OLED_SET_PAGE);
	oled_send_command(OLED_PAGE_START);
	oled_send_command(OLED_PAGE_END);
	oled_send_command(OLED_SET_COLUMN);
	oled_send_command(OLED_COLUMN_START);
	oled_send_command(OLED_COLUMN_END);
	
	// Reverse column and row mapping 
	oled_send_command(OLED_SEG_REMAP_INV);
	oled_send_command(OLED_COM_SCAN_DIR_INV);
	
	/* Set by default during reset
	oled_send_command(OLED_SET_COM_PINS);
	oled_send_command(OLED_COM_PINS);
	*/
	
	// Set operating characteristics
	oled_send_command(OLED_SET_CONTRAST);
	oled_send_command(OLED_CONTRAST_SETTING);	
	oled_send_command(OLED_SET_PRECHARGE_PER);
	oled_send_command(OLED_PRECHARGE_PER);	
	oled_send_command(OLED_SET_VCOM_DESELECT);
	oled_send_command(OLED_VCOM_DESELECT);
	
	// Turn display back on
	oled_send_command(OLED_DISPLAY_ALLOW_RESUME);
	oled_send_command(OLED_NORMAL_DISPLAY);
	oled_send_command(OLED_DISPLAY_ON);
}

/* Draw a vertical line */
void oled_draw_vline(coordinate x_coord, coordinate y1_coord, coordinate y2_coord) {
	// Out of display bounds checks
	if (OLED_WIDTH <= x_coord) {
		return;
	}
	if ( (OLED_HEIGHT <= y1_coord) && (OLED_HEIGHT <= y2_coord)) {
		return;
	}

	coordinate current_y = y1_coord;
	coordinate end_y = y2_coord;
	if (y2_coord < y1_coord) {
		current_y = y2_coord;
		end_y = y1_coord;
	}
	
	// Cut off line if it runs out of display area 
	if (OLED_HEIGHT <= end_y) {
		end_y = OLED_HEIGHT - 1;
	}

	// Draw the line pixel by pixel
	while (current_y <= end_y) {
		oled_set_pixel(x_coord, current_y, WHITE);
		current_y++;
	}
}

/* Draw a horizontal line */
void oled_draw_hline(coordinate y_coord, coordinate x1_coord, coordinate x2_coord) {
	// Out of display bounds checks
	if (OLED_HEIGHT <= y_coord) {
		return;
	}
	if ( (OLED_WIDTH <= x1_coord) && (OLED_WIDTH <= x2_coord) ) {
		return;
	}

	coordinate current_x = x1_coord;
	coordinate end_x = x2_coord;
	if (x2_coord < x1_coord) {
		current_x = x2_coord;
		end_x = x1_coord;
	}

	// Cut off line if it runs out of display area
	if (OLED_WIDTH <= end_x) {
		end_x = OLED_WIDTH - 1;
	}
	
	// Draw the line pixel by pixel
	while (current_x <= end_x) {
		oled_set_pixel(current_x, y_coord, WHITE);
		current_x++;
	}
}

/* Draw a rectangle outline */
void oled_draw_rect(coordinate x_left, coordinate y_top, coordinate width, 
					coordinate height) {

	// Determine coordinates for bottom right corner of rectangle
	coordinate x_right = x_left + width - 1;
	coordinate y_bottom = y_top + height - 1;

	oled_draw_hline(y_top, x_left, x_right);
	oled_draw_hline(y_bottom, x_left, x_right);
	oled_draw_vline(x_left, y_top, y_bottom);
	oled_draw_vline(x_right, y_top, y_bottom);
}

/* Fill a rectangle */
void oled_fill_rect(coordinate x_left, coordinate y_top, coordinate width,
					coordinate height) {
	
	// Determine coordinates for bottom right corner of rectangle
	coordinate x_right = x_left + width - 1;
	coordinate y_bottom = y_top + height - 1;

	// Run loop to draw lines over shorter of width and height
	if (width <= height) {
		coordinate current_x = x_left;
		while (current_x <= x_right) {
			oled_draw_vline(current_x, y_top, y_bottom);
			current_x++;
		}
	}
	else {
		coordinate current_y = y_top;
		while (current_y <= y_bottom) {
			oled_draw_vline(current_y, x_left, x_right);
			current_y++;
		}
	}
}

/*
 Bitmap format
 - At least as many bytes as the width
 - More bytes if height more than 8
 - Bytes ordered from top left, left to right, then top to bottom
 */
/* Draw a bitmap image (using the display data format) */
void oled_draw_bitmap(const uint8_t *bitmap, coordinate x_left, coordinate y_top, 
					  coordinate width, coordinate height) {
	
	// Height of bitmap in bytes (rounded up)
	uint8_t byte_height = ( (height - 1) / BYTE_LENGTH) + 1;

	// Iterate over each "row of 8 bits" in bitmap
	for (uint8_t byte_row = 0; byte_row < byte_height; byte_row++) {
		
		// Iterate over each column
		for (uint8_t column = 0; column < width; column++) {
			
			// Retrieve the corresponding byte
			uint8_t bitmap_byte = bitmap + column + (byte_row * width);
			uint8_t bitmap_data = pgm_read_byte(bitmap_byte);

			// Set the pixel for each of the 8 bits in the column
			for (uint8_t row = 0; row < BYTE_LENGTH; row++) {
				
				if (bitmap_data & (1 << row)) {
					coordinate x_coord = x_left + column;
					coordinate y_coord = y_top + row + (byte_row * BYTE_LENGTH);
					oled_set_pixel(x_coord, y_coord, WHITE);
				}
			}
		}
	}	
}

/* Draw a single ASCII character */
void oled_draw_char(unsigned char c, coordinate x_left, coordinate y_top, font_size size) {
	uint8_t bytes_in_font = 5;
	
	// Loop through each byte in the character mapping (5)
	for (uint8_t char_column = 0; char_column < bytes_in_font; char_column++) {
		uint16_t byte_address = font + ((c - 32) * bytes_in_font) + char_column;

		// Retrieve character mapping from memory
		uint8_t char_data = pgm_read_byte(byte_address);

		// Loop through each bit in the byte
		for (uint8_t char_row = 0; char_row < BYTE_LENGTH; char_row++) {

			if (char_data & (1 << char_row)) {
				
				// Fill a pixel if the size is SMALL
				if (size == SMALL) {
					coordinate x_coord = x_left + char_column;
					coordinate y_coord = y_top + char_row;
					oled_set_pixel(x_coord, y_coord, WHITE);
				}

				// Fill a rectangle if size is MEDIUM or LARGE
				else {
					coordinate x_coord = x_left + (char_column * size);
					coordinate y_coord = y_top + (char_row * size);
					oled_fill_rect(x_coord, y_coord, size, size);
				}
			}	
		}
	}
}

